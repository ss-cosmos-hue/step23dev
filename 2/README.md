# 宿題1
## お題
ほぼO(1)で動くハッシュテーブルを自分で実装する
## 実装物の説明[関数内に書くコメントとは異なる?]
- 対応コード 
    `hash_table.py`
- 概要
    ハッシュテーブルの検索・追加・削除機能が実装されている。
    ぞれぞれ，keyを検索して対応するvalueを返す(検索機能)，keyとvalueをもとにハッシュテーブルにアイテムを追加する(追加する)keyをもとに対応するアイテムをハッシュテーブルから削除する(削除機能)ように実装されている。
    ほぼO(1)の計算量を保つべく，状況に応じて自動的に再ハッシュする機能がある。
- アルゴリズム
    - ハッシュ関数
        - パスワードとしては使われるのは，英数字と簡単な記号であると考えられ，この場合ASCIIコードの33~126でカバーされる。ここでは，各パスワードを，131(127より大きい最小の素数)進法の表記ととらえ，それに対応する数値をハッシュ関数の出力とする。これにより，異なる入力に対しては異なる出力がされることが担保される。
    - ハッシュテーブル
        - <key,value,次のアイテムのポインタ>を持つアイテムがハッシュテーブルの，(ハッシュ値%ハッシュテーブルのサイズ)で指定される箇所に格納される。すでに連結リストがある場合はその冒頭に連結する。
    - 追加機能
        - 追加すべきアイテムのkeyのハッシュ値をもとに，格納すべき，ハッシュテーブル内の位置を計算する。その箇所に入っている連結リストを初めから走査し，もしすでに該当するkeyがあれば，対応するvalueを必要なら更新する。なければ，連結リストの冒頭に連結する。
    - 削除機能
        - 走査は追加機能と同様に行う。該当アイテムが見つかれば，連結リストにおける一つ前のアイテムと一つ後のアイテムとをつなげることで，削除する。
    - 検索機能
        - 走査は追加機能と同様である。該当アイテムが見つかれば，対応するvalueを返す。
    - 再ハッシュ機能
        - ハッシュテーブルのサイズと保持アイテムの総数から，ハッシュテーブルの粗密を判断し，粗ならばサイズを減らし，密ならば増やす。サイズを変更したのちに，すべての要素を，ハッシュテーブルの追加機能を用いて入れ直す。
- 実行方法
    `python hash_table.py`で実行される。
- 工夫点
    - デバッグがし易いように，ハッシュテーブルの全ての要素を列挙する関数を作成した。
    - 宿題4でのキャッシュでの再利用を可能とするため，アイテムがkey,valueだけでなく，ほかの属性を持てるように拡張した。

# 宿題2
## お題
木構造を使えば O(log N)、ハッシュテーブルを使えばほぼ O(1) で検索・追加・削除を実現することができて、これだけ見ればハッシュテーブルのほうが優れているように見える。ところが現実の大規模なデータベースでは、ハッシュテーブルではなく木構造が使われることが多い。その理由を考えよ。
## 回答
- データの増減に合わせて，構造をスケールする必要があるが，木構造のバランスを保つのに必要な計算量はO(1)であるのに対し，ハッシュテーブルの大きさを変更するのに必要な計算量は,再ハッシュを用いるならO(N)であり，多段ハッシュを用いるとしても最悪O(N)となる。この，実データに合わせた構造のスケーリングを含めると，ハッシュテーブルの方が一時的に，あるいは全体として，計算負荷が大きくなるから。
- ハッシュテーブルにおける，データの検索・追加・削除の計算量をO(1)に保つためには，ハッシュ関数が，異なる入力に対してできるかぎり異なる出力を返すための工夫が必要である。しかし，入力されるデータの特徴を，実用開始まで特定できない場合が現実には考えられ，その場合，適切なハッシュ関数を設定できない可能性がある。
- ハッシュテーブルの場合はデータの検索・追加・削除の計算量は"ほぼ"O(1)であるが，最悪の場合O(N)やそれに準じる計算量となる。実際のデータベースでは，例えばデータ数が利用者数に比例するような場合，O(logN)は十分小さい計算量であるため，ほぼO(1)にするよりも，最悪の計算量O(N)となるリスクを回避する方が優先されるから。
# 挑戦クイズ
## お題
つねに O(1) で検索・追加・削除できるデータ構造はあるか？
## 回答
(考え中，大量のメモリと適切なハッシュ関数があれば可能)
# 宿題3
## お題
次の操作をほぼ O(1) で実現するデータ構造を考える
与えられた <URL, Webページ> があるかないかを検索
もしない場合、キャッシュ内で一番古い <URL, Webページ> を捨てて、かわりに与えられた <URL, Webページ> を追加する(σ⁎˃ᴗ˂⁎)σ
## 回答
もっとも直近にアクセスされた上位X個の<URL, Webページ>を，アクセスが最近なものから最古のものの順に連結リストに格納する。連結リストは最初のアイテムと最後のアイテムのポインタを保持することにする。<--!どれほどの粒度で答えるべきか-->この連結リストでは，それぞれのアイテムは，自身の一つ前のアイテムと一つあとのアイテムのポインタを格納することにする。　　
さらに，<URL, Webページ, 連結リスト内の対応するアイテムのポインタ>をハッシュテーブルに格納することで，以下のように要求を満たすデータ構造が実現できる。　

まず，与えられた<URL,Webページ>があるかないかを検索するには，ハッシュテーブルを用いればよく，計算量はほぼO(1)である。もしない場合に一番古い<URL,Webページ>を捨てるには，まず，連結リストの保持する最後(アクセスは最古)のアイテムを参照し，対応する<URL>のアイテムをハッシュテーブルから消去する。次に，参照したアイテムを連結リストから消去し，連結リストの最後のアイテムとして保持するポインタを更新する。アクセスした<URL,Webページ>を追加するには，まず，連結リストの初めにつなげ，連結リストの最初のアイテムとして保持するポインタを更新する。次に，ハッシュテーブルに<URL,Webページ,連結リストに追加したアイテムのポインタ>を格納する。これらは全て計算量O(1)である。  
なお，格納されたデータ全てを順に参照するには，連結リストをはじめから順に参照すればよい。

# 宿題4
## お題
宿題3のデータ構造の実装
## 実装物の説明
- 対応コード
    - `cache.py`
- 概要
    - 宿題3の回答の第一段落に準じる。
- アルゴリズム
    - 連結リスト
        - もっとも直近にアクセスされた上位X個の<URL, Webページ,1つ前のアイテムのポインタ,1つ後のアイテムのポインタ>を，アクセスが最近なものから最古のものの順に格納する。連結リストは最初のアイテムと最後のアイテムのポインタも保持するする。
    - 連結リストの追加機能(push)
        - 追加すべき<URL,Webページ>をもつ新しいアイテムを作成し，その<一つ後のアイテムのポインタ>を，連結リストの最初のアイテムのポインタに更新する。その後，連結リスㇳの最初のアイテムのポインタを，新しく作成したアイテムのポインタに更新する。
    - 連結リストの削除(pop)機能
        - 連結リストの最後のアイテムの一つ前のアイテムの<一つ後のアイテムのポインタ>を消去する(Noneにする)。その後，連結リストの最後のアイテムを，その一つ前のアイテムに更新する。
    - 連結リストの削除(delete)機能
        - 消去すべきアイテムのポインタを引数とする。当該アイテムの一つ前のアイテムの<一つ後のアイテムポインタ>属性を，当該アイテムの一つ後のアイテムのポインタに更新し，当該アイテムの一つ後のアイテムの<一つ前のアイテムポインタ>属性を，当該アイテムの一つ前のアイテムのポインタに更新する。
    - キャッシュクラス
        - 一対のハッシュテーブルと連結リストを持つ。ハッシュテーブルのアイテムは<other property>属性をもち，連結リストの対応するアイテムのポインタを保持する。
    - キャッシュクラスの検索機能
    ハッシュテーブルを検索する
    - キャッシュテーブルのアクセス反映機能
    与えられた<URL,Webページ>のキャッシュの有無を確認する。ない場合は，履歴の最古のアイテムを消去してから，新しいアイテムを追加する。　　
    ある場合は，連結リストから該当アイテムを削除してから，新しいアイテムを追加する。 
    - キャッシュクラスの追加機能
    連結リストの追加機能を用いる。ハッシュテーブルへも追加するが，この際，追加アイテムの<other property>属性に，連結リストに追加したアイテムのポインタを格納することに注意する。
    - キャッシュクラスの削除機能
    履歴の最古のアイテムを消去するには，連結リストの最後のアイテムのURLを引数としてハッシュテーブルの削除機能を用い，また，連結リストではpop機能をもちいる。
    また，連結リストから，特定のアイテムを削除するには，ハッシュテーブルの検索結果をもとに，検索されたアイテムの<other property>属性に格納されているポインタを，連結リストの削除関数の引数として渡す。
    - キャッシュクラスの検索機能
    ハッシュテーブルの検索機能を用いる。キャッシュの有無の確認にも用いる。
- 実行方法
    `python hash_table.py`で実行される。
- 工夫点
    - pop,push,delete機能をもつ連結リストのクラスを実装することで，cacheクラスをより簡潔にかけるようにした。連結リストができた段階で，連結リストのみのテストをした。
    - 宿題1のデータ構造の再利用をすべく，クラスの継承を行った。
    - デバッグしやすいように，連結リストの全ての要素を前から列挙する関数と，後ろから列挙する関数とを作った。前者は各アイテムの<next pointer>属性が，後者は<previous pointer>属性が正しく更新されていることを確認するためのものである。